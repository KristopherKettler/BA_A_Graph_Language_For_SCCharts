% einleitung.tex
\chapter{Introduction}
The increasing complexity of software systems poses new challenges for software developers. As a result, the use of modeling languages to develop such systems has grown in popularity, helping developers to gain a better understanding of the system. In addition, code generators are often part of such tools, which generate executable code from the designed model that can be integrated into applications. In general, they help to increase the efficiency of the development process. Starting with textual languages such as VHDL for describing hardware or HTML markup language for developing web pages, to graphical modeling languages such as the well known UML, the model-based approach runs through every area of software development. Basically, a distinction is made between general-purpose modeling languages (GPMLs) and domain-specific languages (DSLs). The latter are mostly textual and require Language Workbenches, frameworks that support the development of according editors and tools for DSLs. Thereby, it provides similar features as modern Integrated Development Environments (IDEs). In addition, metamodeling frameworks such as the Eclipse Modeling Framework (EMF) or JetBrains Meta Programming System support the development of editors for DSLs.~\cite{Lybecait.2018}~\cite{Naujokat.2018}

However, the development of complicated domain-specific tools has often proved to be complex and laboriously. Also, most metamodeling frameworks focus on textual modeling languages, including those mentioned above, so support for graphical languages is rather sparse. For these reasons, the \textsc{Cinco} Meta Tooling Suite (\textsc{Cinco}) was developed. It offers a solution for the creation of graph-based modeling tools. Furthermore, it follows a simplicity-oriented approach, which means that universality is limited in favour of simplicity. The core feature of \textsc{Cinco} is the full generation of these domain-specific graphical modeling tools from meta-level specifications and models. This is a significant advantage over other approaches that only support semi-automatic generation of graphical editors from high-level specifications, and where the generated code still needs to be adapted before the editor can be executed.~\cite{Lybecait.2018}~\cite{Naujokat.2018}

\section{Motivation}
Although DSLs are often seen as a means to empower domain experts to create software systems on their own and thus replace programmers, this goal has not yet been achieved. However, it is already possible today for domain experts to understand and verify code written by developers. Nevertheless, DSLs seem to be less popular than GPMLs, of which there are many more variations. Naujokat et al.~\cite{Lybecait.2018} suggest that this is because people consider the complex development of DSL tools to be too complicated and elaborate, and therefore not worthwhile. This observation is the motivation for this bachelor thesis. With \textsc{Cinco} a solution has now been created that facilitates the creation of editors for graphical domain-specific languages by trading generality for simplicity. If it could be shown how easy it is to create a DSL tool using \textsc{Cinco}, this might convince more people to use DSLs and perhaps get one step closer to the vision of empowering domain experts to create their systems themselves with DSL tools.

\section{Problem Statement}
The central issue addressed in this bachelor thesis is the low popularity of DSLs, primarily attributed to the perceived complexity associated with the development of DSL tools. The complexity involved in creating DSL tools often makes it seem unworthy of the investment, leading to a preference for more GPMLs. Consequently, there is a need to investigate and demonstrate how \textsc{Cinco}, a tool that prioritizes simplicity in creating graphical DSL editors, can facilitate the development of such DSL tools. The SCCharts language~\cite{Hanxleden.2014}, a visual modeling language designed for specifying safety-critical reactive systems, was chosen as example of a graphical DSL for which the editor development process is shown.

Using this development process as an example, it should be shown that the development of DSL tools does not have to be tedious and complex, which should contribute to solving the problem of the low use of DSLs. To this purpose, the editor must provide some functionalities to support the development of SCCharts, so that it can be considered as a useful tool for the application of DSL tools. On the one hand, it should be possible to create and extend SCChart models. Potential users must be able to read the created models correctly. The visual syntax of the model created in the editor should therefore be as similar as possible to that of SCCharts. In addition, it should not be possible to create incorrect models or it should be indicated to the user if there are errors in the model. The user interface should be as user-friendly as possible so that users who are not programmers can also use the tool. Finally, the editor should be able to generate code from the created model that can be integrated into software systems. 

\section{Structure}
Chapter \ref{chapter_Foundations} presents the foundations of model-driven software development (Sect. \ref{Model-Driven Software Development}), which are essential for understanding the editor's development process, and introduces the SCCharts language (Sect. \ref{Sequentially_Constructive_Statecharts}), necessary for implementing the editor based on it. In Chapter \ref{Related_Work}, related work is addressed. Subsequently, Chapter \ref{Frameworks_and_Tools} deals with the tools and frameworks that were ultimately used to create the editor for SCCharts. The core of this bachelor thesis, the conception and implementation of the graphical DSL tool for SCCharts, is presented in Chapter \ref{Concept_and_Implementation_of_the_Graph_Language}. First, requirements for the SCCharts tool are defined (Sect. \ref{Requirements}). The data structure is then designed and the Meta Graph Language of the editor is implemented based on it. Then the Style Graph Language is adapted, which specifies the visual syntax of SCCharts components in the editor. Next, the user interface and the model validation are implemented. Finally, the code generator is realised in this Chapter. After the editor has been designed and implemented, it is evaluated in Chapter \ref{Evaluation_of_the_Model_Editor}. Finally, in Chapter \ref{Conclusion} a summary with conclusions is presented.

